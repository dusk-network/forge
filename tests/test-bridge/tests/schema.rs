// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.
//
// Copyright (c) DUSK NETWORK. All rights reserved.

//! Schema tests for the test-bridge contract.
//!
//! These tests load the data-driver WASM and verify that the schema
//! generated by the `#[contract]` macro is correct.

mod test_session;

use wasmtime::*;

const DATA_DRIVER_WASM: &[u8] =
    include_bytes!("../../../target/data-driver/wasm32-unknown-unknown/release/test_bridge.wasm");

/// Load the data-driver WASM and call get_schema to retrieve the contract schema.
fn get_schema_from_wasm() -> String {
    let engine = Engine::default();
    let module = Module::new(&engine, DATA_DRIVER_WASM).expect("Failed to compile WASM");

    let mut store = Store::new(&engine, ());
    let instance = Instance::new(&mut store, &module, &[]).expect("Failed to instantiate WASM");

    // Get the memory
    let memory = instance
        .get_memory(&mut store, "memory")
        .expect("Failed to get memory");

    // Call init() first to register the driver
    let init = instance
        .get_typed_func::<(), ()>(&mut store, "init")
        .expect("Failed to get init function");
    init.call(&mut store, ()).expect("Failed to call init");

    // Get get_schema function
    let get_schema = instance
        .get_typed_func::<(i32, i32), i32>(&mut store, "get_schema")
        .expect("Failed to get get_schema function");

    // Use a fixed offset in linear memory for the output buffer
    // WASM data segment typically starts at a low address, so we use a high offset
    let buf_offset: i32 = 1024 * 64; // 64KB offset should be safe
    let buf_size: i32 = 16 * 1024;   // 16KB buffer

    // Ensure memory is large enough
    let current_pages = memory.size(&store);
    let needed_pages = ((buf_offset + buf_size) as u64 + 65535) / 65536;
    if current_pages < needed_pages {
        memory
            .grow(&mut store, needed_pages - current_pages)
            .expect("Failed to grow memory");
    }

    // Call get_schema
    let result = get_schema
        .call(&mut store, (buf_offset, buf_size))
        .expect("Failed to call get_schema");

    // Check for errors (ErrorCode::Ok = 0)
    assert_eq!(result, 0, "get_schema returned error code: {result}");

    // Read the result from memory
    // Format: 4-byte little-endian length prefix, then data
    let data = memory.data(&store);
    let len_bytes = &data[buf_offset as usize..buf_offset as usize + 4];
    let len = u32::from_le_bytes([len_bytes[0], len_bytes[1], len_bytes[2], len_bytes[3]]) as usize;

    let schema_start = buf_offset as usize + 4;
    let schema_bytes = &data[schema_start..schema_start + len];
    String::from_utf8(schema_bytes.to_vec()).expect("Schema is not valid UTF-8")
}

#[test]
fn test_schema_contract_name() {
    let schema_json = get_schema_from_wasm();
    let schema: serde_json::Value =
        serde_json::from_str(&schema_json).expect("Failed to parse schema JSON");

    assert_eq!(schema["name"], "TestBridge");
}

#[test]
fn test_schema_has_functions() {
    let schema_json = get_schema_from_wasm();
    let schema: serde_json::Value =
        serde_json::from_str(&schema_json).expect("Failed to parse schema JSON");

    let functions = schema["functions"].as_array().expect("functions should be an array");
    let fn_names: Vec<&str> = functions
        .iter()
        .map(|f| f["name"].as_str().unwrap())
        .collect();

    // Check inherent methods are present
    assert!(fn_names.contains(&"init"), "missing init");
    assert!(fn_names.contains(&"is_paused"), "missing is_paused");
    assert!(fn_names.contains(&"pause"), "missing pause");
    assert!(fn_names.contains(&"unpause"), "missing unpause");
    assert!(fn_names.contains(&"finalization_period"), "missing finalization_period");
    assert!(fn_names.contains(&"deposit"), "missing deposit");
    assert!(fn_names.contains(&"pending_withdrawal"), "missing pending_withdrawal");

    // Check exposed trait methods are present
    assert!(fn_names.contains(&"owner"), "missing owner");
    assert!(fn_names.contains(&"transfer_ownership"), "missing transfer_ownership");
    assert!(fn_names.contains(&"renounce_ownership"), "missing renounce_ownership");

    // Check private methods are NOT present
    assert!(!fn_names.contains(&"only_owner"), "only_owner should not be exported");
    assert!(!fn_names.contains(&"owner_mut"), "owner_mut should not be exported");
}

#[test]
fn test_schema_has_events() {
    let schema_json = get_schema_from_wasm();
    let schema: serde_json::Value =
        serde_json::from_str(&schema_json).expect("Failed to parse schema JSON");

    let events = schema["events"].as_array().expect("events should be an array");
    let event_topics: Vec<&str> = events
        .iter()
        .map(|e| e["topic"].as_str().unwrap())
        .collect();

    // Check event topics
    assert!(
        event_topics.iter().any(|t| t.contains("PauseToggled")),
        "missing PauseToggled event"
    );
    assert!(
        event_topics.iter().any(|t| t.contains("TransactionDeposited")),
        "missing TransactionDeposited event"
    );
    assert!(
        event_topics.iter().any(|t| t.contains("BridgeFinalized")),
        "missing BridgeFinalized event"
    );
}

#[test]
fn test_schema_has_imports() {
    let schema_json = get_schema_from_wasm();
    let schema: serde_json::Value =
        serde_json::from_str(&schema_json).expect("Failed to parse schema JSON");

    let imports = schema["imports"].as_array().expect("imports should be an array");
    let import_names: Vec<&str> = imports
        .iter()
        .map(|i| i["name"].as_str().unwrap())
        .collect();

    // Check key imports
    assert!(import_names.contains(&"Deposit"), "missing Deposit import");
    assert!(import_names.contains(&"EVMAddress"), "missing EVMAddress import");
    assert!(import_names.contains(&"events"), "missing events import");
}

#[test]
#[ignore]
fn print_schema() {
    let schema_json = get_schema_from_wasm();
    let schema: serde_json::Value =
        serde_json::from_str(&schema_json).expect("Failed to parse schema JSON");
    println!("{}", serde_json::to_string_pretty(&schema).unwrap());
}

/// Helper struct for calling data-driver functions via WASM.
struct DataDriverWasm {
    store: Store<()>,
    instance: Instance,
}

impl DataDriverWasm {
    fn new() -> Self {
        let engine = Engine::default();
        let module = Module::new(&engine, DATA_DRIVER_WASM).expect("Failed to compile WASM");

        let mut store = Store::new(&engine, ());
        let instance = Instance::new(&mut store, &module, &[]).expect("Failed to instantiate WASM");

        // Call init() to register the driver
        let init = instance
            .get_typed_func::<(), ()>(&mut store, "init")
            .expect("Failed to get init function");
        init.call(&mut store, ()).expect("Failed to call init");

        Self { store, instance }
    }

    /// Call get_last_error to retrieve the error message after a failed operation.
    fn get_last_error(&mut self) -> String {
        let memory = self
            .instance
            .get_memory(&mut self.store, "memory")
            .expect("Failed to get memory");

        let get_error = self
            .instance
            .get_typed_func::<(i32, i32), i32>(&mut self.store, "get_last_error")
            .expect("Failed to get get_last_error function");

        let out_offset = 1024 * 16; // Use a different offset to avoid conflicts
        let out_size = 4096;

        let result = get_error
            .call(&mut self.store, (out_offset as i32, out_size as i32))
            .expect("Failed to call get_last_error");

        if result != 0 {
            return format!("get_last_error failed with code {result}");
        }

        let data = memory.data(&self.store);
        let len_bytes = &data[out_offset..out_offset + 4];
        let len =
            u32::from_le_bytes([len_bytes[0], len_bytes[1], len_bytes[2], len_bytes[3]]) as usize;
        String::from_utf8_lossy(&data[out_offset + 4..out_offset + 4 + len]).to_string()
    }

    /// Call encode_input_fn via the WASM interface.
    fn encode_input(&mut self, fn_name: &str, json: &str) -> Result<Vec<u8>, String> {
        let memory = self
            .instance
            .get_memory(&mut self.store, "memory")
            .expect("Failed to get memory");

        // Grow memory if needed
        let current_pages = memory.size(&self.store);
        if current_pages < 4 {
            memory
                .grow(&mut self.store, 4 - current_pages)
                .expect("Failed to grow memory");
        }

        let encode_fn = self
            .instance
            .get_typed_func::<(i32, i32, i32, i32, i32, i32), i32>(&mut self.store, "encode_input_fn")
            .expect("Failed to get encode_input_fn function");

        // Write fn_name to memory
        let fn_name_offset = 1024;
        let fn_name_bytes = fn_name.as_bytes();
        memory.data_mut(&mut self.store)[fn_name_offset..fn_name_offset + fn_name_bytes.len()]
            .copy_from_slice(fn_name_bytes);

        // Write json to memory
        let json_offset = fn_name_offset + 256;
        let json_bytes = json.as_bytes();
        memory.data_mut(&mut self.store)[json_offset..json_offset + json_bytes.len()]
            .copy_from_slice(json_bytes);

        // Output buffer
        let out_offset = json_offset + 4096;
        let out_size = 4096;

        let result = encode_fn
            .call(
                &mut self.store,
                (
                    fn_name_offset as i32,
                    fn_name_bytes.len() as i32,
                    json_offset as i32,
                    json_bytes.len() as i32,
                    out_offset as i32,
                    out_size as i32,
                ),
            )
            .expect("Failed to call encode_input_fn");

        if result != 0 {
            let msg = self.get_last_error();
            return Err(format!("Error code {result}: {msg}"));
        }

        // Read successful result (4-byte length prefix + data)
        let data = memory.data(&self.store);
        let len_bytes = &data[out_offset..out_offset + 4];
        let len =
            u32::from_le_bytes([len_bytes[0], len_bytes[1], len_bytes[2], len_bytes[3]]) as usize;
        Ok(data[out_offset + 4..out_offset + 4 + len].to_vec())
    }

    /// Call decode_output_fn via the WASM interface.
    fn decode_output(&mut self, fn_name: &str, rkyv: &[u8]) -> Result<serde_json::Value, String> {
        self.decode_with_name("decode_output_fn", fn_name, rkyv)
    }

    /// Call decode_event via the WASM interface.
    fn decode_event(&mut self, event_name: &str, rkyv: &[u8]) -> Result<serde_json::Value, String> {
        self.decode_with_name("decode_event", event_name, rkyv)
    }

    /// Generic decode helper for decode_output_fn and decode_event.
    fn decode_with_name(
        &mut self,
        wasm_fn: &str,
        name: &str,
        rkyv: &[u8],
    ) -> Result<serde_json::Value, String> {
        let memory = self
            .instance
            .get_memory(&mut self.store, "memory")
            .expect("Failed to get memory");

        let decode_fn = self
            .instance
            .get_typed_func::<(i32, i32, i32, i32, i32, i32), i32>(&mut self.store, wasm_fn)
            .unwrap_or_else(|_| panic!("Failed to get {wasm_fn} function"));

        // Write name to memory
        let name_offset = 1024;
        let name_bytes = name.as_bytes();
        memory.data_mut(&mut self.store)[name_offset..name_offset + name_bytes.len()]
            .copy_from_slice(name_bytes);

        // Write rkyv data to memory
        let rkyv_offset = name_offset + 256;
        memory.data_mut(&mut self.store)[rkyv_offset..rkyv_offset + rkyv.len()]
            .copy_from_slice(rkyv);

        // Output buffer
        let out_offset = rkyv_offset + 4096;
        let out_size = 4096;

        let result = decode_fn
            .call(
                &mut self.store,
                (
                    name_offset as i32,
                    name_bytes.len() as i32,
                    rkyv_offset as i32,
                    rkyv.len() as i32,
                    out_offset as i32,
                    out_size as i32,
                ),
            )
            .unwrap_or_else(|_| panic!("Failed to call {wasm_fn}"));

        if result != 0 {
            let msg = self.get_last_error();
            return Err(format!("Error code {result}: {msg}"));
        }

        // Read successful result (4-byte length prefix + JSON data)
        let data = memory.data(&self.store);
        let len_bytes = &data[out_offset..out_offset + 4];
        let len =
            u32::from_le_bytes([len_bytes[0], len_bytes[1], len_bytes[2], len_bytes[3]]) as usize;
        let json_str = String::from_utf8_lossy(&data[out_offset + 4..out_offset + 4 + len]);
        serde_json::from_str(&json_str).map_err(|e| e.to_string())
    }
}

#[test]
fn test_custom_data_driver_function_encode() {
    let mut driver = DataDriverWasm::new();

    // Test encoding an EVMAddress via the custom "extra_data" function
    // EVMAddress serializes as a hex string
    let input_json = r#""0x0102030405060708090a0b0c0d0e0f1011121314""#;
    let encoded = driver
        .encode_input("extra_data", input_json)
        .expect("Failed to encode extra_data");

    // The custom encoder returns the raw bytes of the EVMAddress
    assert_eq!(encoded.len(), 20, "Expected 20 bytes for EVMAddress");
    assert_eq!(
        encoded,
        vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]
    );
}

#[test]
fn test_custom_data_driver_function_decode() {
    let mut driver = DataDriverWasm::new();

    // Test decoding raw bytes back to EVMAddress via the custom "extra_data" function
    let rkyv_data: Vec<u8> = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20];
    let decoded = driver
        .decode_output("extra_data", &rkyv_data)
        .expect("Failed to decode extra_data");

    // The custom decoder returns the EVMAddress as a hex string
    let expected: serde_json::Value = serde_json::json!("0x0102030405060708090a0b0c0d0e0f1011121314");
    assert_eq!(decoded, expected);
}

#[test]
fn test_custom_data_driver_function_roundtrip() {
    let mut driver = DataDriverWasm::new();

    // Encode an EVMAddress (hex string format)
    let original_json = r#""0xaabbccdd00112233445566778899aabbccddeeff""#;
    let encoded = driver
        .encode_input("extra_data", original_json)
        .expect("Failed to encode extra_data");

    // Decode it back
    let decoded = driver
        .decode_output("extra_data", &encoded)
        .expect("Failed to decode extra_data");

    // Verify roundtrip - note: hex output may have different case
    let decoded_str = decoded.as_str().expect("Expected string");
    assert_eq!(
        decoded_str.to_lowercase(),
        "0xaabbccdd00112233445566778899aabbccddeeff"
    );
}

// =============================================================================
// Tests for #[contract(feeds = "Type")] attribute
// =============================================================================

#[test]
fn test_schema_has_feed_functions() {
    let schema_json = get_schema_from_wasm();
    let schema: serde_json::Value =
        serde_json::from_str(&schema_json).expect("Failed to parse schema JSON");

    let functions = schema["functions"].as_array().expect("functions should be an array");
    let fn_names: Vec<&str> = functions
        .iter()
        .map(|f| f["name"].as_str().unwrap())
        .collect();

    // Check streaming functions are present
    assert!(
        fn_names.contains(&"pending_withdrawals"),
        "missing pending_withdrawals"
    );
    assert!(
        fn_names.contains(&"pending_withdrawal_ids"),
        "missing pending_withdrawal_ids"
    );

    // Verify the schema shows () as output (the Rust return type)
    let pending_withdrawals_fn = functions
        .iter()
        .find(|f| f["name"] == "pending_withdrawals")
        .expect("pending_withdrawals not found");
    assert_eq!(
        pending_withdrawals_fn["output"].as_str().unwrap(),
        "()",
        "pending_withdrawals should have () as output in schema"
    );
}

#[test]
fn test_feed_function_decode_uses_feed_type() {
    use dusk_core::abi::ContractId;
    use types::{EVMAddress, PendingWithdrawal, WithdrawalId};
    use types::Address as DSAddress;

    let mut driver = DataDriverWasm::new();

    // Create test data: (WithdrawalId, PendingWithdrawal) tuple
    let withdrawal_id = WithdrawalId([1u8; 32]);
    // Create a DSAddress using a ContractId (32-byte array)
    let contract_id = ContractId::from_bytes([3u8; 32]);
    let pending = PendingWithdrawal {
        from: EVMAddress([2u8; 20]),
        to: DSAddress::Contract(contract_id),
        amount: 1000,
        block_height: 42,
    };

    // Serialize the tuple using rkyv
    let rkyv_data = rkyv::to_bytes::<_, 256>(&(withdrawal_id, pending))
        .expect("Failed to serialize tuple");

    // Decode using the data-driver
    // This should use the feed_type "(WithdrawalId, PendingWithdrawal)", NOT return null
    let decoded = driver
        .decode_output("pending_withdrawals", &rkyv_data)
        .expect("Failed to decode pending_withdrawals output");

    // Verify we got an array (tuple serializes as array in JSON)
    assert!(
        decoded.is_array(),
        "Expected array (tuple), got: {decoded:?}"
    );

    let arr = decoded.as_array().unwrap();
    assert_eq!(arr.len(), 2, "Expected 2-element tuple");

    // First element is WithdrawalId - may serialize as hex string or array depending on serde impl
    // Just verify it exists and is not null
    assert!(
        !arr[0].is_null(),
        "First element (WithdrawalId) should not be null: {decoded:?}"
    );

    // Second element is PendingWithdrawal struct
    assert!(arr[1].is_object(), "Second element should be PendingWithdrawal object");
    assert!(arr[1]["amount"].is_number(), "PendingWithdrawal should have amount field");
    assert_eq!(arr[1]["amount"], 1000);
    assert_eq!(arr[1]["block_height"], 42);
}

#[test]
fn test_feed_function_simple_type_decode() {
    use types::WithdrawalId;

    let mut driver = DataDriverWasm::new();

    // Create test data: just a WithdrawalId
    let withdrawal_id = WithdrawalId([3u8; 32]);

    // Serialize using rkyv
    let rkyv_data = rkyv::to_bytes::<_, 256>(&withdrawal_id)
        .expect("Failed to serialize WithdrawalId");

    // Decode using the data-driver
    // This should use the feed_type "WithdrawalId", NOT return null
    let decoded = driver
        .decode_output("pending_withdrawal_ids", &rkyv_data)
        .expect("Failed to decode pending_withdrawal_ids output");

    // WithdrawalId serializes as a hex string with serde
    // The key assertion is that it's NOT null (which would happen without the feeds attribute)
    assert!(
        !decoded.is_null(),
        "Expected non-null WithdrawalId, got null. The feeds attribute is not working!"
    );

    // If it's a string, verify it contains the expected hex pattern
    if let Some(s) = decoded.as_str() {
        // 32 bytes of 0x03 -> "0303...03" (64 hex chars)
        assert!(
            s.len() >= 64,
            "Expected hex string of at least 64 chars, got: {s}"
        );
        assert!(
            s.chars().all(|c| c.is_ascii_hexdigit()),
            "Expected hex string, got: {s}"
        );
    }
    // Could also be an array depending on serialization - just verify it exists
}

// =============================================================================
// Tests for decode_event (using actual contract events)
// =============================================================================

use std::sync::LazyLock;

use dusk_core::abi::ContractId;
use dusk_core::dusk;
use dusk_core::signatures::bls::{PublicKey as AccountPublicKey, SecretKey as AccountSecretKey};
use types::{Deposit, EVMAddress};
use types::Address as DSAddress;
use rand::rngs::StdRng;
use rand::SeedableRng;
use test_session::TestSession;

const TEST_BRIDGE_BYTECODE: &[u8] =
    include_bytes!("../../../target/contract/wasm32-unknown-unknown/release/test_bridge.wasm");
const TEST_BRIDGE_ID: ContractId = ContractId::from_bytes([1; 32]);
const DEPLOYER: [u8; 64] = [0u8; 64];
const INITIAL_BALANCE: u64 = dusk(1_000.0);

static OWNER_SK: LazyLock<AccountSecretKey> = LazyLock::new(|| {
    let mut rng = StdRng::seed_from_u64(0x5EAF00D);
    AccountSecretKey::random(&mut rng)
});
static OWNER_PK: LazyLock<AccountPublicKey> =
    LazyLock::new(|| AccountPublicKey::from(&*OWNER_SK));
static OWNER_ADDRESS: LazyLock<DSAddress> = LazyLock::new(|| DSAddress::from(*OWNER_PK));

/// Set up a contract session for event tests.
fn setup_contract_session() -> TestSession {
    let mut session = TestSession::instantiate(vec![(&*OWNER_PK, INITIAL_BALANCE)], vec![]);

    session
        .deploy(
            TEST_BRIDGE_BYTECODE,
            dusk_vm::ContractData::builder()
                .owner(DEPLOYER)
                .init_arg(&(*OWNER_ADDRESS,))
                .contract_id(TEST_BRIDGE_ID),
        )
        .expect("Deploying test-bridge should succeed");

    session
}

#[test]
fn test_decode_event_pause_toggled() {
    // 1. Call the contract to emit a real event
    let mut session = setup_contract_session();
    let receipt = session
        .call_public::<_, ()>(&OWNER_SK, TEST_BRIDGE_ID, "pause", &())
        .expect("pause should succeed");

    // 2. Extract the event from the receipt
    assert!(!receipt.events.is_empty(), "pause should emit an event");
    let event = &receipt.events[0];
    assert_eq!(event.topic, "bridge_paused");

    // 3. Decode the event using the data-driver
    let mut driver = DataDriverWasm::new();
    let decoded = driver
        .decode_event(&event.topic, &event.data)
        .expect("Failed to decode PauseToggled event");

    // PauseToggled is a unit struct, may serialize to null or empty array
    assert!(
        decoded.is_null() || (decoded.is_array() && decoded.as_array().unwrap().is_empty()),
        "PauseToggled should serialize to null or empty array, got: {decoded:?}"
    );
}

#[test]
fn test_decode_event_bridge_initiated() {
    // 1. Call the contract to emit a real BridgeInitiated event
    let mut session = setup_contract_session();

    let deposit = Deposit {
        to: EVMAddress([1u8; 20]),
        amount: 1000,
        fee: 10,
        extra_data: vec![0xAB, 0xCD],
    };

    let receipt = session
        .call_public::<_, ()>(&OWNER_SK, TEST_BRIDGE_ID, "deposit", &deposit)
        .expect("deposit should succeed");

    // 2. Find the BridgeInitiated event (deposit emits multiple events)
    let event = receipt
        .events
        .iter()
        .find(|e| e.topic == "bridge_initiated")
        .expect("deposit should emit bridge_initiated event");

    // 3. Decode the event using the data-driver
    let mut driver = DataDriverWasm::new();
    let decoded = driver
        .decode_event(&event.topic, &event.data)
        .expect("Failed to decode BridgeInitiated event");

    // Verify the decoded fields match what we sent
    assert!(decoded.is_object(), "BridgeInitiated should be an object");
    assert_eq!(decoded["amount"], 1000);
    assert_eq!(decoded["deposit_fee"], 10);

    // extra_data should be present as an array
    assert!(
        decoded["extra_data"].is_array(),
        "extra_data should be an array"
    );
}

// =============================================================================
// Negative tests for error handling
// =============================================================================

#[test]
fn test_encode_input_unknown_function() {
    let mut driver = DataDriverWasm::new();

    let result = driver.encode_input("nonexistent_function", "{}");

    assert!(result.is_err(), "Should fail for unknown function");
    let err = result.unwrap_err();
    assert!(
        err.contains("unknown fn") || err.contains("Unknown"),
        "Error should mention unknown function: {err}"
    );
}

#[test]
fn test_encode_input_malformed_json() {
    let mut driver = DataDriverWasm::new();

    // "pause" expects () input, but we send invalid JSON
    let result = driver.encode_input("pause", "not valid json {{{");

    assert!(result.is_err(), "Should fail for malformed JSON");
}

#[test]
fn test_decode_output_unknown_function() {
    let mut driver = DataDriverWasm::new();

    let result = driver.decode_output("nonexistent_function", &[]);

    assert!(result.is_err(), "Should fail for unknown function");
    let err = result.unwrap_err();
    assert!(
        err.contains("unknown fn") || err.contains("Unknown"),
        "Error should mention unknown function: {err}"
    );
}

#[test]
fn test_decode_output_malformed_rkyv() {
    let mut driver = DataDriverWasm::new();

    // "is_paused" returns bool, but we send garbage bytes
    let result = driver.decode_output("is_paused", &[0xFF, 0xFF, 0xFF]);

    assert!(result.is_err(), "Should fail for malformed rkyv data");
}

#[test]
fn test_decode_event_unknown_topic() {
    let mut driver = DataDriverWasm::new();

    let result = driver.decode_event("unknown_event_topic", &[]);

    assert!(result.is_err(), "Should fail for unknown event topic");
    let err = result.unwrap_err();
    assert!(
        err.contains("unknown event") || err.contains("Unknown"),
        "Error should mention unknown event: {err}"
    );
}

// =============================================================================
// Schema detail verification tests
// =============================================================================

#[test]
fn test_schema_function_input_output_types() {
    let schema_json = get_schema_from_wasm();
    let schema: serde_json::Value =
        serde_json::from_str(&schema_json).expect("Failed to parse schema JSON");

    let functions = schema["functions"].as_array().expect("functions should be an array");

    // Test is_paused: no input, returns bool
    let is_paused = functions
        .iter()
        .find(|f| f["name"] == "is_paused")
        .expect("is_paused should exist");
    assert_eq!(is_paused["input"], "()", "is_paused input should be ()");
    assert_eq!(is_paused["output"], "bool", "is_paused output should be bool");

    // Test init: takes DSAddress, returns ()
    let init = functions
        .iter()
        .find(|f| f["name"] == "init")
        .expect("init should exist");
    let init_input = init["input"].as_str().unwrap();
    assert!(
        init_input.contains("Address"),
        "init input should contain Address: {init_input}"
    );
    assert_eq!(init["output"], "()", "init output should be ()");

    // Test finalization_period: no input, returns u64
    let fin_period = functions
        .iter()
        .find(|f| f["name"] == "finalization_period")
        .expect("finalization_period should exist");
    assert_eq!(fin_period["input"], "()", "finalization_period input should be ()");
    assert_eq!(fin_period["output"], "u64", "finalization_period output should be u64");

    // Test deposit: takes Deposit type, returns ()
    let deposit = functions
        .iter()
        .find(|f| f["name"] == "deposit")
        .expect("deposit should exist");
    let deposit_input = deposit["input"].as_str().unwrap();
    assert!(
        deposit_input.contains("Deposit"),
        "deposit input should contain Deposit: {deposit_input}"
    );
    assert_eq!(deposit["output"], "()", "deposit output should be ()");

    // Test pending_withdrawal: takes WithdrawalId, returns Option<PendingWithdrawal>
    let pending = functions
        .iter()
        .find(|f| f["name"] == "pending_withdrawal")
        .expect("pending_withdrawal should exist");
    let pending_input = pending["input"].as_str().unwrap();
    let pending_output = pending["output"].as_str().unwrap();
    assert!(
        pending_input.contains("WithdrawalId"),
        "pending_withdrawal input should contain WithdrawalId: {pending_input}"
    );
    assert!(
        pending_output.contains("Option") && pending_output.contains("PendingWithdrawal"),
        "pending_withdrawal output should be Option<PendingWithdrawal>: {pending_output}"
    );
}

#[test]
fn test_schema_function_with_multiple_params() {
    let schema_json = get_schema_from_wasm();
    let schema: serde_json::Value =
        serde_json::from_str(&schema_json).expect("Failed to parse schema JSON");

    let functions = schema["functions"].as_array().expect("functions should be an array");

    // Test initiate_transfer: takes (EVMAddress, DSAddress, u64)
    let transfer = functions
        .iter()
        .find(|f| f["name"] == "initiate_transfer")
        .expect("initiate_transfer should exist");
    let input = transfer["input"].as_str().unwrap();

    // Input should be a tuple containing the three parameter types
    assert!(
        input.contains("EVMAddress"),
        "initiate_transfer input should contain EVMAddress: {input}"
    );
    assert!(
        input.contains("u64"),
        "initiate_transfer input should contain u64: {input}"
    );
}

#[test]
fn test_schema_doc_comments() {
    let schema_json = get_schema_from_wasm();
    let schema: serde_json::Value =
        serde_json::from_str(&schema_json).expect("Failed to parse schema JSON");

    let functions = schema["functions"].as_array().expect("functions should be an array");

    // is_paused has doc comment "Returns whether the bridge is paused."
    let is_paused = functions
        .iter()
        .find(|f| f["name"] == "is_paused")
        .expect("is_paused should exist");
    let doc = is_paused["doc"].as_str().unwrap_or("");
    assert!(
        doc.contains("paused"),
        "is_paused doc should mention 'paused', got: {doc}"
    );

    // pause has doc comment "Pauses the bridge."
    let pause = functions
        .iter()
        .find(|f| f["name"] == "pause")
        .expect("pause should exist");
    let doc = pause["doc"].as_str().unwrap_or("");
    assert!(
        doc.contains("Pause"),
        "pause doc should mention 'Pause', got: {doc}"
    );

    // finalization_period has doc comment "Returns the finalization period."
    let fin_period = functions
        .iter()
        .find(|f| f["name"] == "finalization_period")
        .expect("finalization_period should exist");
    let doc = fin_period["doc"].as_str().unwrap_or("");
    assert!(
        doc.contains("finalization"),
        "finalization_period doc should mention 'finalization', got: {doc}"
    );
}

#[test]
fn test_schema_event_details() {
    let schema_json = get_schema_from_wasm();
    let schema: serde_json::Value =
        serde_json::from_str(&schema_json).expect("Failed to parse schema JSON");

    let events = schema["events"].as_array().expect("events should be an array");

    // Find BridgeInitiated event and verify data type
    let bridge_initiated = events
        .iter()
        .find(|e| {
            e["topic"]
                .as_str()
                .map(|t| t.contains("BridgeInitiated"))
                .unwrap_or(false)
        })
        .expect("BridgeInitiated event should exist");

    let data_type = bridge_initiated["data"].as_str().unwrap();
    assert!(
        data_type.contains("BridgeInitiated"),
        "BridgeInitiated data type should contain BridgeInitiated: {data_type}"
    );

    // Find BridgeFinalized event
    let bridge_finalized = events
        .iter()
        .find(|e| {
            e["topic"]
                .as_str()
                .map(|t| t.contains("BridgeFinalized"))
                .unwrap_or(false)
        })
        .expect("BridgeFinalized event should exist");

    let data_type = bridge_finalized["data"].as_str().unwrap();
    assert!(
        data_type.contains("BridgeFinalized"),
        "BridgeFinalized data type should contain BridgeFinalized: {data_type}"
    );
}

#[test]
fn test_schema_import_paths() {
    let schema_json = get_schema_from_wasm();
    let schema: serde_json::Value =
        serde_json::from_str(&schema_json).expect("Failed to parse schema JSON");

    let imports = schema["imports"].as_array().expect("imports should be an array");

    // Verify Deposit import has full path
    let deposit_import = imports
        .iter()
        .find(|i| i["name"] == "Deposit")
        .expect("Deposit import should exist");

    let path = deposit_import["path"].as_str().unwrap();
    assert!(
        path.contains("types"),
        "Deposit path should be fully qualified with types: {path}"
    );

    // Verify EVMAddress import
    let evm_addr_import = imports
        .iter()
        .find(|i| i["name"] == "EVMAddress")
        .expect("EVMAddress import should exist");

    let path = evm_addr_import["path"].as_str().unwrap();
    assert!(
        path.contains("types"),
        "EVMAddress path should be fully qualified: {path}"
    );

    // Verify events import
    let events_import = imports
        .iter()
        .find(|i| i["name"] == "events")
        .expect("events import should exist");

    let path = events_import["path"].as_str().unwrap();
    assert!(
        path.contains("types"),
        "events path should be qualified: {path}"
    );
}

#[test]
fn test_schema_custom_flag() {
    let schema_json = get_schema_from_wasm();
    let schema: serde_json::Value =
        serde_json::from_str(&schema_json).expect("Failed to parse schema JSON");

    let functions = schema["functions"].as_array().expect("functions should be an array");

    // Regular functions should have custom = false
    let is_paused = functions
        .iter()
        .find(|f| f["name"] == "is_paused")
        .expect("is_paused should exist");
    assert_eq!(
        is_paused["custom"], false,
        "is_paused should not be custom"
    );

    let pause = functions
        .iter()
        .find(|f| f["name"] == "pause")
        .expect("pause should exist");
    assert_eq!(pause["custom"], false, "pause should not be custom");
}

#[test]
fn test_schema_nested_generic_types() {
    let schema_json = get_schema_from_wasm();
    let schema: serde_json::Value =
        serde_json::from_str(&schema_json).expect("Failed to parse schema JSON");

    let functions = schema["functions"].as_array().expect("functions should be an array");

    // Test pending_withdrawal_with_id which returns Option<(WithdrawalId, PendingWithdrawal)>
    let fn_with_nested = functions
        .iter()
        .find(|f| f["name"] == "pending_withdrawal_with_id")
        .expect("pending_withdrawal_with_id should exist");

    let output_type = fn_with_nested["output"].as_str().unwrap();

    // The output type should be a nested generic: Option containing a tuple
    assert!(
        output_type.contains("Option"),
        "Output should be Option type: {output_type}"
    );
    assert!(
        output_type.contains("WithdrawalId") || output_type.contains("("),
        "Output should contain tuple or WithdrawalId: {output_type}"
    );
    assert!(
        output_type.contains("PendingWithdrawal"),
        "Output should contain PendingWithdrawal: {output_type}"
    );

    // Test that simpler Option types are also captured
    let pending_withdrawal = functions
        .iter()
        .find(|f| f["name"] == "pending_withdrawal")
        .expect("pending_withdrawal should exist");

    let output_type = pending_withdrawal["output"].as_str().unwrap();
    assert!(
        output_type.contains("Option"),
        "pending_withdrawal output should be Option: {output_type}"
    );
    assert!(
        output_type.contains("PendingWithdrawal"),
        "pending_withdrawal output should contain PendingWithdrawal: {output_type}"
    );
}

#[test]
fn test_schema_multiple_impl_blocks() {
    let schema_json = get_schema_from_wasm();
    let schema: serde_json::Value =
        serde_json::from_str(&schema_json).expect("Failed to parse schema JSON");

    let functions = schema["functions"].as_array().expect("functions should be an array");
    let fn_names: Vec<&str> = functions
        .iter()
        .map(|f| f["name"].as_str().unwrap())
        .collect();

    // Functions from the FIRST impl block (new is const fn, not exported)
    assert!(fn_names.contains(&"init"), "missing init from first impl block");
    assert!(fn_names.contains(&"is_paused"), "missing is_paused from first impl block");
    assert!(fn_names.contains(&"pause"), "missing pause from first impl block");
    assert!(fn_names.contains(&"unpause"), "missing unpause from first impl block");
    assert!(fn_names.contains(&"finalization_period"), "missing finalization_period from first impl block");
    assert!(fn_names.contains(&"set_u64"), "missing set_u64 from first impl block");
    assert!(fn_names.contains(&"set_evm_address_or_offset"), "missing set_evm_address_or_offset from first impl block");
    assert!(fn_names.contains(&"other_bridge"), "missing other_bridge from first impl block");

    // Functions from the SECOND impl block
    assert!(fn_names.contains(&"deposit"), "missing deposit from second impl block");
    assert!(fn_names.contains(&"pending_withdrawal"), "missing pending_withdrawal from second impl block");
    assert!(fn_names.contains(&"other_bridge_ref"), "missing other_bridge_ref from second impl block");
    assert!(fn_names.contains(&"verify_withdrawal"), "missing verify_withdrawal from second impl block");
    assert!(fn_names.contains(&"initiate_transfer"), "missing initiate_transfer from second impl block");
    assert!(fn_names.contains(&"add_pending_withdrawal"), "missing add_pending_withdrawal from second impl block");
    assert!(fn_names.contains(&"finalize_withdrawal"), "missing finalize_withdrawal from second impl block");
    assert!(fn_names.contains(&"pending_withdrawals"), "missing pending_withdrawals from second impl block");
    assert!(fn_names.contains(&"pending_withdrawal_ids"), "missing pending_withdrawal_ids from second impl block");

    // Verify OwnableUpgradeable trait methods are present
    assert!(fn_names.contains(&"owner"), "missing owner from OwnableUpgradeable trait impl");
    assert!(fn_names.contains(&"transfer_ownership"), "missing transfer_ownership from OwnableUpgradeable trait impl");
    assert!(fn_names.contains(&"renounce_ownership"), "missing renounce_ownership from OwnableUpgradeable trait impl");

    // Verify Pausable trait methods are present (second trait implementation)
    assert!(fn_names.contains(&"paused"), "missing paused from Pausable trait impl");
    assert!(fn_names.contains(&"toggle_pause"), "missing toggle_pause from Pausable trait impl");
}

// =============================================================================
// Schema JSON compliance tests
// =============================================================================

#[test]
fn test_schema_is_valid_json() {
    let schema_json = get_schema_from_wasm();

    // Verify it's valid UTF-8 (already checked in get_schema_from_wasm)
    assert!(!schema_json.is_empty(), "Schema should not be empty");

    // Verify it parses as valid JSON
    let result: Result<serde_json::Value, _> = serde_json::from_str(&schema_json);
    assert!(result.is_ok(), "Schema should be valid JSON: {:?}", result.err());

    // Verify it's a JSON object (not array, string, etc.)
    let schema = result.unwrap();
    assert!(schema.is_object(), "Schema root should be a JSON object");
}

#[test]
fn test_schema_has_required_top_level_fields() {
    let schema_json = get_schema_from_wasm();
    let schema: serde_json::Value =
        serde_json::from_str(&schema_json).expect("Failed to parse schema JSON");

    let obj = schema.as_object().expect("Schema should be an object");

    // Required top-level fields
    assert!(obj.contains_key("name"), "Schema must have 'name' field");
    assert!(obj.contains_key("functions"), "Schema must have 'functions' field");
    assert!(obj.contains_key("events"), "Schema must have 'events' field");
    assert!(obj.contains_key("imports"), "Schema must have 'imports' field");

    // Verify types of top-level fields
    assert!(schema["name"].is_string(), "'name' must be a string");
    assert!(schema["functions"].is_array(), "'functions' must be an array");
    assert!(schema["events"].is_array(), "'events' must be an array");
    assert!(schema["imports"].is_array(), "'imports' must be an array");
}

#[test]
fn test_schema_function_fields_consistent() {
    let schema_json = get_schema_from_wasm();
    let schema: serde_json::Value =
        serde_json::from_str(&schema_json).expect("Failed to parse schema JSON");

    let functions = schema["functions"].as_array().expect("functions should be an array");

    for (i, func) in functions.iter().enumerate() {
        let func_obj = func.as_object()
            .unwrap_or_else(|| panic!("Function at index {i} should be an object"));

        // Required fields for every function
        assert!(
            func_obj.contains_key("name"),
            "Function at index {i} missing 'name' field"
        );
        assert!(
            func_obj.contains_key("input"),
            "Function at index {i} missing 'input' field"
        );
        assert!(
            func_obj.contains_key("output"),
            "Function at index {i} missing 'output' field"
        );
        assert!(
            func_obj.contains_key("custom"),
            "Function at index {i} missing 'custom' field"
        );

        // Verify field types
        let name = &func["name"];
        assert!(
            name.is_string(),
            "Function at index {i}: 'name' must be string, got {name:?}"
        );

        let input = &func["input"];
        assert!(
            input.is_string(),
            "Function at index {i}: 'input' must be string, got {input:?}"
        );

        let output = &func["output"];
        assert!(
            output.is_string(),
            "Function at index {i}: 'output' must be string, got {output:?}"
        );

        let custom = &func["custom"];
        assert!(
            custom.is_boolean(),
            "Function at index {i}: 'custom' must be boolean, got {custom:?}"
        );

        // 'doc' is optional but if present must be string or null
        if let Some(doc) = func_obj.get("doc") {
            assert!(
                doc.is_string() || doc.is_null(),
                "Function at index {i}: 'doc' must be string or null, got {doc:?}"
            );
        }
    }
}

#[test]
fn test_schema_event_fields_consistent() {
    let schema_json = get_schema_from_wasm();
    let schema: serde_json::Value =
        serde_json::from_str(&schema_json).expect("Failed to parse schema JSON");

    let events = schema["events"].as_array().expect("events should be an array");

    for (i, event) in events.iter().enumerate() {
        let event_obj = event.as_object()
            .unwrap_or_else(|| panic!("Event at index {i} should be an object"));

        // Required fields for every event
        assert!(
            event_obj.contains_key("topic"),
            "Event at index {i} missing 'topic' field"
        );
        assert!(
            event_obj.contains_key("data"),
            "Event at index {i} missing 'data' field"
        );

        // Verify field types
        let topic = &event["topic"];
        assert!(
            topic.is_string(),
            "Event at index {i}: 'topic' must be string, got {topic:?}"
        );

        let data = &event["data"];
        assert!(
            data.is_string(),
            "Event at index {i}: 'data' must be string, got {data:?}"
        );

        // Topic should not be empty
        let topic_str = topic.as_str().unwrap();
        assert!(
            !topic_str.is_empty(),
            "Event at index {i}: 'topic' should not be empty"
        );
    }
}

#[test]
fn test_schema_import_fields_consistent() {
    let schema_json = get_schema_from_wasm();
    let schema: serde_json::Value =
        serde_json::from_str(&schema_json).expect("Failed to parse schema JSON");

    let imports = schema["imports"].as_array().expect("imports should be an array");

    for (i, import) in imports.iter().enumerate() {
        let import_obj = import.as_object()
            .unwrap_or_else(|| panic!("Import at index {i} should be an object"));

        // Required fields for every import
        assert!(
            import_obj.contains_key("name"),
            "Import at index {i} missing 'name' field"
        );
        assert!(
            import_obj.contains_key("path"),
            "Import at index {i} missing 'path' field"
        );

        // Verify field types
        let name = &import["name"];
        assert!(
            name.is_string(),
            "Import at index {i}: 'name' must be string, got {name:?}"
        );

        let path = &import["path"];
        assert!(
            path.is_string(),
            "Import at index {i}: 'path' must be string, got {path:?}"
        );

        // Name should not be empty
        let name_str = name.as_str().unwrap();
        assert!(
            !name_str.is_empty(),
            "Import at index {i}: 'name' should not be empty"
        );

        // Path should not be empty
        let path_str = path.as_str().unwrap();
        assert!(
            !path_str.is_empty(),
            "Import at index {i}: 'path' should not be empty"
        );
    }
}

#[test]
fn test_schema_no_duplicate_function_names() {
    let schema_json = get_schema_from_wasm();
    let schema: serde_json::Value =
        serde_json::from_str(&schema_json).expect("Failed to parse schema JSON");

    let functions = schema["functions"].as_array().expect("functions should be an array");
    let fn_names: Vec<&str> = functions
        .iter()
        .map(|f| f["name"].as_str().unwrap())
        .collect();

    // Check for duplicates
    let mut seen = std::collections::HashSet::new();
    for name in &fn_names {
        assert!(
            seen.insert(*name),
            "Duplicate function name in schema: {name}"
        );
    }
}

#[test]
fn test_schema_no_duplicate_event_topics() {
    let schema_json = get_schema_from_wasm();
    let schema: serde_json::Value =
        serde_json::from_str(&schema_json).expect("Failed to parse schema JSON");

    let events = schema["events"].as_array().expect("events should be an array");
    let topics: Vec<&str> = events
        .iter()
        .map(|e| e["topic"].as_str().unwrap())
        .collect();

    // Check for duplicates
    let mut seen = std::collections::HashSet::new();
    for topic in &topics {
        assert!(
            seen.insert(*topic),
            "Duplicate event topic in schema: {topic}"
        );
    }
}
