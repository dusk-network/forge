// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.
//
// Copyright (c) DUSK NETWORK. All rights reserved.

//! Schema tests for the test-bridge contract.
//!
//! These tests load the data-driver WASM and verify that the schema
//! generated by the `#[contract]` macro is correct.

use wasmtime::*;

const DATA_DRIVER_WASM: &[u8] =
    include_bytes!("../../../target/data-driver/wasm32-unknown-unknown/release/test_bridge.wasm");

/// Load the data-driver WASM and call get_schema to retrieve the contract schema.
fn get_schema_from_wasm() -> String {
    let engine = Engine::default();
    let module = Module::new(&engine, DATA_DRIVER_WASM).expect("Failed to compile WASM");

    let mut store = Store::new(&engine, ());
    let instance = Instance::new(&mut store, &module, &[]).expect("Failed to instantiate WASM");

    // Get the memory
    let memory = instance
        .get_memory(&mut store, "memory")
        .expect("Failed to get memory");

    // Call init() first to register the driver
    let init = instance
        .get_typed_func::<(), ()>(&mut store, "init")
        .expect("Failed to get init function");
    init.call(&mut store, ()).expect("Failed to call init");

    // Get get_schema function
    let get_schema = instance
        .get_typed_func::<(i32, i32), i32>(&mut store, "get_schema")
        .expect("Failed to get get_schema function");

    // Use a fixed offset in linear memory for the output buffer
    // WASM data segment typically starts at a low address, so we use a high offset
    let buf_offset: i32 = 1024 * 64; // 64KB offset should be safe
    let buf_size: i32 = 16 * 1024;   // 16KB buffer

    // Ensure memory is large enough
    let current_pages = memory.size(&store);
    let needed_pages = ((buf_offset + buf_size) as u64 + 65535) / 65536;
    if current_pages < needed_pages {
        memory
            .grow(&mut store, needed_pages - current_pages)
            .expect("Failed to grow memory");
    }

    // Call get_schema
    let result = get_schema
        .call(&mut store, (buf_offset, buf_size))
        .expect("Failed to call get_schema");

    // Check for errors (ErrorCode::Ok = 0)
    assert_eq!(result, 0, "get_schema returned error code: {result}");

    // Read the result from memory
    // Format: 4-byte little-endian length prefix, then data
    let data = memory.data(&store);
    let len_bytes = &data[buf_offset as usize..buf_offset as usize + 4];
    let len = u32::from_le_bytes([len_bytes[0], len_bytes[1], len_bytes[2], len_bytes[3]]) as usize;

    let schema_start = buf_offset as usize + 4;
    let schema_bytes = &data[schema_start..schema_start + len];
    String::from_utf8(schema_bytes.to_vec()).expect("Schema is not valid UTF-8")
}

#[test]
fn test_schema_contract_name() {
    let schema_json = get_schema_from_wasm();
    let schema: serde_json::Value =
        serde_json::from_str(&schema_json).expect("Failed to parse schema JSON");

    assert_eq!(schema["name"], "TestBridge");
}

#[test]
fn test_schema_has_functions() {
    let schema_json = get_schema_from_wasm();
    let schema: serde_json::Value =
        serde_json::from_str(&schema_json).expect("Failed to parse schema JSON");

    let functions = schema["functions"].as_array().expect("functions should be an array");
    let fn_names: Vec<&str> = functions
        .iter()
        .map(|f| f["name"].as_str().unwrap())
        .collect();

    // Check inherent methods are present
    assert!(fn_names.contains(&"init"), "missing init");
    assert!(fn_names.contains(&"is_paused"), "missing is_paused");
    assert!(fn_names.contains(&"pause"), "missing pause");
    assert!(fn_names.contains(&"unpause"), "missing unpause");
    assert!(fn_names.contains(&"finalization_period"), "missing finalization_period");
    assert!(fn_names.contains(&"deposit"), "missing deposit");
    assert!(fn_names.contains(&"pending_withdrawal"), "missing pending_withdrawal");

    // Check exposed trait methods are present
    assert!(fn_names.contains(&"owner"), "missing owner");
    assert!(fn_names.contains(&"transfer_ownership"), "missing transfer_ownership");
    assert!(fn_names.contains(&"renounce_ownership"), "missing renounce_ownership");

    // Check private methods are NOT present
    assert!(!fn_names.contains(&"only_owner"), "only_owner should not be exported");
    assert!(!fn_names.contains(&"owner_mut"), "owner_mut should not be exported");
}

#[test]
fn test_schema_has_events() {
    let schema_json = get_schema_from_wasm();
    let schema: serde_json::Value =
        serde_json::from_str(&schema_json).expect("Failed to parse schema JSON");

    let events = schema["events"].as_array().expect("events should be an array");
    let event_topics: Vec<&str> = events
        .iter()
        .map(|e| e["topic"].as_str().unwrap())
        .collect();

    // Check event topics
    assert!(
        event_topics.iter().any(|t| t.contains("PauseToggled")),
        "missing PauseToggled event"
    );
    assert!(
        event_topics.iter().any(|t| t.contains("TransactionDeposited")),
        "missing TransactionDeposited event"
    );
    assert!(
        event_topics.iter().any(|t| t.contains("BridgeFinalized")),
        "missing BridgeFinalized event"
    );
}

#[test]
fn test_schema_has_imports() {
    let schema_json = get_schema_from_wasm();
    let schema: serde_json::Value =
        serde_json::from_str(&schema_json).expect("Failed to parse schema JSON");

    let imports = schema["imports"].as_array().expect("imports should be an array");
    let import_names: Vec<&str> = imports
        .iter()
        .map(|i| i["name"].as_str().unwrap())
        .collect();

    // Check key imports
    assert!(import_names.contains(&"Deposit"), "missing Deposit import");
    assert!(import_names.contains(&"EVMAddress"), "missing EVMAddress import");
    assert!(import_names.contains(&"events"), "missing events import");
}

#[test]
#[ignore]
fn print_schema() {
    let schema_json = get_schema_from_wasm();
    let schema: serde_json::Value =
        serde_json::from_str(&schema_json).expect("Failed to parse schema JSON");
    println!("{}", serde_json::to_string_pretty(&schema).unwrap());
}
