// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.
//
// Copyright (c) DUSK NETWORK. All rights reserved.

//! Schema tests for the test-bridge contract.
//!
//! These tests load the data-driver WASM and verify that the schema
//! generated by the `#[contract]` macro is correct.

use wasmtime::*;

const DATA_DRIVER_WASM: &[u8] =
    include_bytes!("../../../target/data-driver/wasm32-unknown-unknown/release/test_bridge.wasm");

/// Load the data-driver WASM and call get_schema to retrieve the contract schema.
fn get_schema_from_wasm() -> String {
    let engine = Engine::default();
    let module = Module::new(&engine, DATA_DRIVER_WASM).expect("Failed to compile WASM");

    let mut store = Store::new(&engine, ());
    let instance = Instance::new(&mut store, &module, &[]).expect("Failed to instantiate WASM");

    // Get the memory
    let memory = instance
        .get_memory(&mut store, "memory")
        .expect("Failed to get memory");

    // Call init() first to register the driver
    let init = instance
        .get_typed_func::<(), ()>(&mut store, "init")
        .expect("Failed to get init function");
    init.call(&mut store, ()).expect("Failed to call init");

    // Get get_schema function
    let get_schema = instance
        .get_typed_func::<(i32, i32), i32>(&mut store, "get_schema")
        .expect("Failed to get get_schema function");

    // Use a fixed offset in linear memory for the output buffer
    // WASM data segment typically starts at a low address, so we use a high offset
    let buf_offset: i32 = 1024 * 64; // 64KB offset should be safe
    let buf_size: i32 = 16 * 1024;   // 16KB buffer

    // Ensure memory is large enough
    let current_pages = memory.size(&store);
    let needed_pages = ((buf_offset + buf_size) as u64 + 65535) / 65536;
    if current_pages < needed_pages {
        memory
            .grow(&mut store, needed_pages - current_pages)
            .expect("Failed to grow memory");
    }

    // Call get_schema
    let result = get_schema
        .call(&mut store, (buf_offset, buf_size))
        .expect("Failed to call get_schema");

    // Check for errors (ErrorCode::Ok = 0)
    assert_eq!(result, 0, "get_schema returned error code: {result}");

    // Read the result from memory
    // Format: 4-byte little-endian length prefix, then data
    let data = memory.data(&store);
    let len_bytes = &data[buf_offset as usize..buf_offset as usize + 4];
    let len = u32::from_le_bytes([len_bytes[0], len_bytes[1], len_bytes[2], len_bytes[3]]) as usize;

    let schema_start = buf_offset as usize + 4;
    let schema_bytes = &data[schema_start..schema_start + len];
    String::from_utf8(schema_bytes.to_vec()).expect("Schema is not valid UTF-8")
}

#[test]
fn test_schema_contract_name() {
    let schema_json = get_schema_from_wasm();
    let schema: serde_json::Value =
        serde_json::from_str(&schema_json).expect("Failed to parse schema JSON");

    assert_eq!(schema["name"], "TestBridge");
}

#[test]
fn test_schema_has_functions() {
    let schema_json = get_schema_from_wasm();
    let schema: serde_json::Value =
        serde_json::from_str(&schema_json).expect("Failed to parse schema JSON");

    let functions = schema["functions"].as_array().expect("functions should be an array");
    let fn_names: Vec<&str> = functions
        .iter()
        .map(|f| f["name"].as_str().unwrap())
        .collect();

    // Check inherent methods are present
    assert!(fn_names.contains(&"init"), "missing init");
    assert!(fn_names.contains(&"is_paused"), "missing is_paused");
    assert!(fn_names.contains(&"pause"), "missing pause");
    assert!(fn_names.contains(&"unpause"), "missing unpause");
    assert!(fn_names.contains(&"finalization_period"), "missing finalization_period");
    assert!(fn_names.contains(&"deposit"), "missing deposit");
    assert!(fn_names.contains(&"pending_withdrawal"), "missing pending_withdrawal");

    // Check exposed trait methods are present
    assert!(fn_names.contains(&"owner"), "missing owner");
    assert!(fn_names.contains(&"transfer_ownership"), "missing transfer_ownership");
    assert!(fn_names.contains(&"renounce_ownership"), "missing renounce_ownership");

    // Check private methods are NOT present
    assert!(!fn_names.contains(&"only_owner"), "only_owner should not be exported");
    assert!(!fn_names.contains(&"owner_mut"), "owner_mut should not be exported");
}

#[test]
fn test_schema_has_events() {
    let schema_json = get_schema_from_wasm();
    let schema: serde_json::Value =
        serde_json::from_str(&schema_json).expect("Failed to parse schema JSON");

    let events = schema["events"].as_array().expect("events should be an array");
    let event_topics: Vec<&str> = events
        .iter()
        .map(|e| e["topic"].as_str().unwrap())
        .collect();

    // Check event topics
    assert!(
        event_topics.iter().any(|t| t.contains("PauseToggled")),
        "missing PauseToggled event"
    );
    assert!(
        event_topics.iter().any(|t| t.contains("TransactionDeposited")),
        "missing TransactionDeposited event"
    );
    assert!(
        event_topics.iter().any(|t| t.contains("BridgeFinalized")),
        "missing BridgeFinalized event"
    );
}

#[test]
fn test_schema_has_imports() {
    let schema_json = get_schema_from_wasm();
    let schema: serde_json::Value =
        serde_json::from_str(&schema_json).expect("Failed to parse schema JSON");

    let imports = schema["imports"].as_array().expect("imports should be an array");
    let import_names: Vec<&str> = imports
        .iter()
        .map(|i| i["name"].as_str().unwrap())
        .collect();

    // Check key imports
    assert!(import_names.contains(&"Deposit"), "missing Deposit import");
    assert!(import_names.contains(&"EVMAddress"), "missing EVMAddress import");
    assert!(import_names.contains(&"events"), "missing events import");
}

#[test]
#[ignore]
fn print_schema() {
    let schema_json = get_schema_from_wasm();
    let schema: serde_json::Value =
        serde_json::from_str(&schema_json).expect("Failed to parse schema JSON");
    println!("{}", serde_json::to_string_pretty(&schema).unwrap());
}

/// Helper struct for calling data-driver functions via WASM.
struct DataDriverWasm {
    store: Store<()>,
    instance: Instance,
}

impl DataDriverWasm {
    fn new() -> Self {
        let engine = Engine::default();
        let module = Module::new(&engine, DATA_DRIVER_WASM).expect("Failed to compile WASM");

        let mut store = Store::new(&engine, ());
        let instance = Instance::new(&mut store, &module, &[]).expect("Failed to instantiate WASM");

        // Call init() to register the driver
        let init = instance
            .get_typed_func::<(), ()>(&mut store, "init")
            .expect("Failed to get init function");
        init.call(&mut store, ()).expect("Failed to call init");

        Self { store, instance }
    }

    /// Call encode_input_fn via the WASM interface.
    fn encode_input(&mut self, fn_name: &str, json: &str) -> Result<Vec<u8>, String> {
        let memory = self
            .instance
            .get_memory(&mut self.store, "memory")
            .expect("Failed to get memory");

        // Grow memory if needed
        let current_pages = memory.size(&self.store);
        if current_pages < 4 {
            memory
                .grow(&mut self.store, 4 - current_pages)
                .expect("Failed to grow memory");
        }

        let encode_fn = self
            .instance
            .get_typed_func::<(i32, i32, i32, i32, i32, i32), i32>(&mut self.store, "encode_input_fn")
            .expect("Failed to get encode_input_fn function");

        // Write fn_name to memory
        let fn_name_offset = 1024;
        let fn_name_bytes = fn_name.as_bytes();
        memory.data_mut(&mut self.store)[fn_name_offset..fn_name_offset + fn_name_bytes.len()]
            .copy_from_slice(fn_name_bytes);

        // Write json to memory
        let json_offset = fn_name_offset + 256;
        let json_bytes = json.as_bytes();
        memory.data_mut(&mut self.store)[json_offset..json_offset + json_bytes.len()]
            .copy_from_slice(json_bytes);

        // Output buffer
        let out_offset = json_offset + 4096;
        let out_size = 4096;

        let result = encode_fn
            .call(
                &mut self.store,
                (
                    fn_name_offset as i32,
                    fn_name_bytes.len() as i32,
                    json_offset as i32,
                    json_bytes.len() as i32,
                    out_offset as i32,
                    out_size as i32,
                ),
            )
            .expect("Failed to call encode_input_fn");

        if result != 0 {
            // Read error message
            let data = memory.data(&self.store);
            let len_bytes = &data[out_offset..out_offset + 4];
            let len =
                u32::from_le_bytes([len_bytes[0], len_bytes[1], len_bytes[2], len_bytes[3]]) as usize;
            let msg = String::from_utf8_lossy(&data[out_offset + 4..out_offset + 4 + len]);
            return Err(format!("Error code {result}: {msg}"));
        }

        // Read successful result (4-byte length prefix + data)
        let data = memory.data(&self.store);
        let len_bytes = &data[out_offset..out_offset + 4];
        let len =
            u32::from_le_bytes([len_bytes[0], len_bytes[1], len_bytes[2], len_bytes[3]]) as usize;
        Ok(data[out_offset + 4..out_offset + 4 + len].to_vec())
    }

    /// Call decode_output_fn via the WASM interface.
    fn decode_output(&mut self, fn_name: &str, rkyv: &[u8]) -> Result<serde_json::Value, String> {
        let memory = self
            .instance
            .get_memory(&mut self.store, "memory")
            .expect("Failed to get memory");

        let decode_fn = self
            .instance
            .get_typed_func::<(i32, i32, i32, i32, i32, i32), i32>(
                &mut self.store,
                "decode_output_fn",
            )
            .expect("Failed to get decode_output_fn function");

        // Write fn_name to memory
        let fn_name_offset = 1024;
        let fn_name_bytes = fn_name.as_bytes();
        memory.data_mut(&mut self.store)[fn_name_offset..fn_name_offset + fn_name_bytes.len()]
            .copy_from_slice(fn_name_bytes);

        // Write rkyv data to memory
        let rkyv_offset = fn_name_offset + 256;
        memory.data_mut(&mut self.store)[rkyv_offset..rkyv_offset + rkyv.len()]
            .copy_from_slice(rkyv);

        // Output buffer
        let out_offset = rkyv_offset + 4096;
        let out_size = 4096;

        let result = decode_fn
            .call(
                &mut self.store,
                (
                    fn_name_offset as i32,
                    fn_name_bytes.len() as i32,
                    rkyv_offset as i32,
                    rkyv.len() as i32,
                    out_offset as i32,
                    out_size as i32,
                ),
            )
            .expect("Failed to call decode_output_fn");

        if result != 0 {
            // Read error message
            let data = memory.data(&self.store);
            let len_bytes = &data[out_offset..out_offset + 4];
            let len =
                u32::from_le_bytes([len_bytes[0], len_bytes[1], len_bytes[2], len_bytes[3]]) as usize;
            let msg = String::from_utf8_lossy(&data[out_offset + 4..out_offset + 4 + len]);
            return Err(format!("Error code {result}: {msg}"));
        }

        // Read successful result (4-byte length prefix + JSON data)
        let data = memory.data(&self.store);
        let len_bytes = &data[out_offset..out_offset + 4];
        let len =
            u32::from_le_bytes([len_bytes[0], len_bytes[1], len_bytes[2], len_bytes[3]]) as usize;
        let json_str = String::from_utf8_lossy(&data[out_offset + 4..out_offset + 4 + len]);
        serde_json::from_str(&json_str).map_err(|e| e.to_string())
    }
}

#[test]
fn test_custom_data_driver_function_encode() {
    let mut driver = DataDriverWasm::new();

    // Test encoding an EVMAddress via the custom "extra_data" function
    // EVMAddress serializes as a hex string
    let input_json = r#""0x0102030405060708090a0b0c0d0e0f1011121314""#;
    let encoded = driver
        .encode_input("extra_data", input_json)
        .expect("Failed to encode extra_data");

    // The custom encoder returns the raw bytes of the EVMAddress
    assert_eq!(encoded.len(), 20, "Expected 20 bytes for EVMAddress");
    assert_eq!(
        encoded,
        vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]
    );
}

#[test]
fn test_custom_data_driver_function_decode() {
    let mut driver = DataDriverWasm::new();

    // Test decoding raw bytes back to EVMAddress via the custom "extra_data" function
    let rkyv_data: Vec<u8> = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20];
    let decoded = driver
        .decode_output("extra_data", &rkyv_data)
        .expect("Failed to decode extra_data");

    // The custom decoder returns the EVMAddress as a hex string
    let expected: serde_json::Value = serde_json::json!("0x0102030405060708090a0B0c0d0e0f1011121314");
    assert_eq!(decoded, expected);
}

#[test]
fn test_custom_data_driver_function_roundtrip() {
    let mut driver = DataDriverWasm::new();

    // Encode an EVMAddress (hex string format)
    let original_json = r#""0xaabbccdd00112233445566778899aabbccddeeff""#;
    let encoded = driver
        .encode_input("extra_data", original_json)
        .expect("Failed to encode extra_data");

    // Decode it back
    let decoded = driver
        .decode_output("extra_data", &encoded)
        .expect("Failed to decode extra_data");

    // Verify roundtrip - note: hex output may have different case
    let decoded_str = decoded.as_str().expect("Expected string");
    assert_eq!(
        decoded_str.to_lowercase(),
        "0xaabbccdd00112233445566778899aabbccddeeff"
    );
}

// =============================================================================
// Tests for #[contract(feeds = "Type")] attribute
// =============================================================================

#[test]
fn test_schema_has_feed_functions() {
    let schema_json = get_schema_from_wasm();
    let schema: serde_json::Value =
        serde_json::from_str(&schema_json).expect("Failed to parse schema JSON");

    let functions = schema["functions"].as_array().expect("functions should be an array");
    let fn_names: Vec<&str> = functions
        .iter()
        .map(|f| f["name"].as_str().unwrap())
        .collect();

    // Check streaming functions are present
    assert!(
        fn_names.contains(&"pending_withdrawals"),
        "missing pending_withdrawals"
    );
    assert!(
        fn_names.contains(&"pending_withdrawal_ids"),
        "missing pending_withdrawal_ids"
    );

    // Verify the schema shows () as output (the Rust return type)
    let pending_withdrawals_fn = functions
        .iter()
        .find(|f| f["name"] == "pending_withdrawals")
        .expect("pending_withdrawals not found");
    assert_eq!(
        pending_withdrawals_fn["output"].as_str().unwrap(),
        "()",
        "pending_withdrawals should have () as output in schema"
    );
}

#[test]
fn test_feed_function_decode_uses_feed_type() {
    use dusk_core::abi::ContractId;
    use evm_core::standard_bridge::{EVMAddress, PendingWithdrawal, WithdrawalId};
    use evm_core::Address as DSAddress;

    let mut driver = DataDriverWasm::new();

    // Create test data: (WithdrawalId, PendingWithdrawal) tuple
    let withdrawal_id = WithdrawalId([1u8; 32]);
    // Create a DSAddress using a ContractId (32-byte array)
    let contract_id = ContractId::from_bytes([3u8; 32]);
    let pending = PendingWithdrawal {
        from: EVMAddress([2u8; 20]),
        to: DSAddress::Contract(contract_id),
        amount: 1000,
        block_height: 42,
    };

    // Serialize the tuple using rkyv
    let rkyv_data = rkyv::to_bytes::<_, 256>(&(withdrawal_id, pending))
        .expect("Failed to serialize tuple");

    // Decode using the data-driver
    // This should use the feed_type "(WithdrawalId, PendingWithdrawal)", NOT return null
    let decoded = driver
        .decode_output("pending_withdrawals", &rkyv_data)
        .expect("Failed to decode pending_withdrawals output");

    // Verify we got an array (tuple serializes as array in JSON)
    assert!(
        decoded.is_array(),
        "Expected array (tuple), got: {decoded:?}"
    );

    let arr = decoded.as_array().unwrap();
    assert_eq!(arr.len(), 2, "Expected 2-element tuple");

    // First element is WithdrawalId - may serialize as hex string or array depending on serde impl
    // Just verify it exists and is not null
    assert!(
        !arr[0].is_null(),
        "First element (WithdrawalId) should not be null: {decoded:?}"
    );

    // Second element is PendingWithdrawal struct
    assert!(arr[1].is_object(), "Second element should be PendingWithdrawal object");
    assert!(arr[1]["amount"].is_number(), "PendingWithdrawal should have amount field");
    assert_eq!(arr[1]["amount"], 1000);
    assert_eq!(arr[1]["block_height"], 42);
}

#[test]
fn test_feed_function_simple_type_decode() {
    use evm_core::standard_bridge::WithdrawalId;

    let mut driver = DataDriverWasm::new();

    // Create test data: just a WithdrawalId
    let withdrawal_id = WithdrawalId([3u8; 32]);

    // Serialize using rkyv
    let rkyv_data = rkyv::to_bytes::<_, 256>(&withdrawal_id)
        .expect("Failed to serialize WithdrawalId");

    // Decode using the data-driver
    // This should use the feed_type "WithdrawalId", NOT return null
    let decoded = driver
        .decode_output("pending_withdrawal_ids", &rkyv_data)
        .expect("Failed to decode pending_withdrawal_ids output");

    // WithdrawalId serializes as a hex string with serde
    // The key assertion is that it's NOT null (which would happen without the feeds attribute)
    assert!(
        !decoded.is_null(),
        "Expected non-null WithdrawalId, got null. The feeds attribute is not working!"
    );

    // If it's a string, verify it contains the expected hex pattern
    if let Some(s) = decoded.as_str() {
        // 32 bytes of 0x03 -> "0303...03" (64 hex chars)
        assert!(
            s.len() >= 64,
            "Expected hex string of at least 64 chars, got: {s}"
        );
        assert!(
            s.chars().all(|c| c.is_ascii_hexdigit()),
            "Expected hex string, got: {s}"
        );
    }
    // Could also be an array depending on serialization - just verify it exists
}
